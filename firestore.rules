/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for all data.
 *
 * Data Structure:
 * - /userAccounts/{userId}: Stores UserProfile data. Only the user can read/write their own profile.
 * - /userAccounts/{userId}/customers/{customerId}: Stores Customer data. Only the owning user can manage their customers.
 * - /userAccounts/{userId}/proposals/{proposalId}: Stores Proposal data. Only the owning user can manage their proposals.
 * - /userAccounts/{userId}/priceBookEntries/{priceBookEntryId}: Stores PriceBookItem data. Only the owning user can manage their price book entries.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Data shape is not strictly enforced during this prototyping phase, except for ownership fields.
 * - All write operations validate ownership based on the authenticated user's UID.
 * - `id` field consistency is enforced on `create` operations to establish relational integrity.
 * - `id` immutability is enforced on `update` operations to prevent unauthorized ownership changes.
 *
 * Denormalization for Authorization:
 *  - The `userId` field in the Customer, Proposal, and PriceBookItem entities is used to enforce ownership, avoiding the need for complex queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Prevents access to any documents not explicitly matched by other rules.
     * @path /
     * @allow None
     * @deny All
     * @principle Default deny-all policy.
     */
    match /{document=**} {
      allow read: if false;
      allow write: if false;
    }

    /**
     * @description Manages user profile information. Only the authenticated user can read or write their own profile.
     * @path /userAccounts/{userId}
     * @allow (get, create, update, delete) - User 'user_abc' can read/write /userAccounts/user_abc
     * @deny (create, update, delete) - User 'user_xyz' cannot write /userAccounts/user_abc
     * @principle Enforces user-ownership for profile data.
     */
    match /userAccounts/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages customer data for a specific user. Only the owning user can create, read, update, or delete customer documents under their account.
     * @path /userAccounts/{userId}/customers/{customerId}
     * @allow (create) User 'user_abc' can create a customer document under /userAccounts/user_abc/customers/customer_123 if customer.userId == 'user_abc'
     * @allow (get, list, update, delete) User 'user_abc' can read/write /userAccounts/user_abc/customers/customer_123
     * @deny (create, update, delete) User 'user_xyz' cannot write /userAccounts/user_abc/customers/customer_123
     * @deny (create) User 'user_abc' cannot create a customer document under /userAccounts/user_abc/customers/customer_123 if customer.userId != 'user_abc'
     * @principle Enforces user-ownership for customer data within the user's data tree.
     */
    match /userAccounts/{userId}/customers/{customerId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId && request.resource.data.id == customerId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages proposal data for a specific user. Only the owning user can create, read, update, or delete proposal documents under their account.
     * @path /userAccounts/{userId}/proposals/{proposalId}
     * @allow (create) User 'user_abc' can create a proposal document under /userAccounts/user_abc/proposals/proposal_456 if proposal.userId == 'user_abc'
     * @allow (get, list, update, delete) User 'user_abc' can read/write /userAccounts/user_abc/proposals/proposal_456
     * @deny (create, update, delete) User 'user_xyz' cannot write /userAccounts/user_abc/proposals/proposal_456
     * @deny (create) User 'user_abc' cannot create a proposal document under /userAccounts/user_abc/proposals/proposal_456 if proposal.userId != 'user_abc'
     * @principle Enforces user-ownership for proposal data within the user's data tree.
     */
    match /userAccounts/{userId}/proposals/{proposalId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId && request.resource.data.id == proposalId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages price book entries for a specific user. Only the owning user can create, read, update, or delete price book entry documents under their account.
     * @path /userAccounts/{userId}/priceBookEntries/{priceBookEntryId}
     * @allow (create) User 'user_abc' can create a price book entry document under /userAccounts/user_abc/priceBookEntries/entry_789 if entry.userId == 'user_abc'
     * @allow (get, list, update, delete) User 'user_abc' can read/write /userAccounts/user_abc/priceBookEntries/entry_789
     * @deny (create, update, delete) User 'user_xyz' cannot write /userAccounts/user_abc/priceBookEntries/entry_789
     * @deny (create) User 'user_abc' cannot create a price book entry document under /userAccounts/user_abc/priceBookEntries/entry_789 if entry.userId != 'user_abc'
     * @principle Enforces user-ownership for price book entry data within the user's data tree.
     */
    match /userAccounts/{userId}/priceBookEntries/{priceBookEntryId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId && request.resource.data.id == priceBookEntryId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }
  }
}