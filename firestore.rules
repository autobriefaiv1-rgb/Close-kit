/**
 * @file Firestore Security Rules
 * @core-philosophy This ruleset enforces a strict user-ownership model.  Each user has a dedicated data tree under `/userAccounts/{userId}`. Only the authenticated user matching the `{userId}` can read or write data within their own tree.
 * @data-structure Data is organized hierarchically under `/userAccounts/{userId}`, including customer, proposal, and price book entry data.
 * @key-security-decisions User listing is disallowed.  Ambiguous relationships default to owner-only access. Data schema is not strictly enforced beyond ownership validation.
 * @denormalization Authorization decisions are based on path-based ownership, eliminating the need for extra reads.
 * @structural-segregation All user data is private and stored under user-specific subcollections. There is no public data in this model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Denies all read and write access to the entire database by default. This ensures a secure starting point.
     * @path /
     * @allow None
     * @deny Any operation.  This is the base rule and is always enforced unless overridden by a more specific rule.
     * @principle Default deny.  This is a standard security practice to prevent accidental data exposure.
     */
    match /{document=**} {
      allow read, write: if false;
    }

    /**
     * @description Manages user profile data.  Allows authenticated users to read their own profile and create their profile if their auth UID matches the document ID.
     * @path /userAccounts/{userId}
     * @allow (get, list) - Any authenticated user can read any profile.
     * @allow (create) - A user can create their own profile if `request.auth.uid == userId`.
     * @allow (update, delete) - A user can update or delete their profile if they are the owner.
     * @deny (create) - A user cannot create a profile with an ID that does not match their auth UID.
     * @deny (update, delete) - A user cannot modify or delete another user's profile.
     * @principle Enforces document ownership for writes and allows public reads.
     */
    match /userAccounts/{userId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages customer data for a specific user. Only the owning user can read, create, update, or delete customers under their account.
     * @path /userAccounts/{userId}/customers/{customerId}
     * @allow (get, list) - The owner (userId) can read any customer under their account.
     * @allow (create) - The owner (userId) can create new customers under their account.  The customer's `userId` field must match the path.
     * @allow (update, delete) - The owner (userId) can modify or delete existing customers under their account.
     * @deny (create) - Another user cannot create a customer under someone else's account.
     * @deny (update, delete) - Another user cannot modify or delete a customer owned by someone else.
     * @principle Restricts access to a user's own data tree.  Validates relational integrity on create.
     */
    match /userAccounts/{userId}/customers/{customerId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages proposal data for a specific user. Only the owning user can read, create, update, or delete proposals under their account.
     * @path /userAccounts/{userId}/proposals/{proposalId}
     * @allow (get, list) - The owner (userId) can read any proposal under their account.
     * @allow (create) - The owner (userId) can create new proposals under their account. The proposal's `userId` field must match the path.
     * @allow (update, delete) - The owner (userId) can modify or delete existing proposals under their account.
     * @deny (create) - Another user cannot create a proposal under someone else's account.
     * @deny (update, delete) - Another user cannot modify or delete a proposal owned by someone else.
     * @principle Restricts access to a user's own data tree. Validates relational integrity on create.
     */
    match /userAccounts/{userId}/proposals/{proposalId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages price book entry data for a specific user. Only the owning user can read, create, update, or delete price book entries under their account.
     * @path /userAccounts/{userId}/priceBookEntries/{priceBookEntryId}
     * @allow (get, list) - The owner (userId) can read any price book entry under their account.
     * @allow (create) - The owner (userId) can create new price book entries under their account.  The entry's `userId` field must match the path.
     * @allow (update, delete) - The owner (userId) can modify or delete existing price book entries under their account.
     * @deny (create) - Another user cannot create a price book entry under someone else's account.
     * @deny (update, delete) - Another user cannot modify or delete a price book entry owned by someone else.
     * @principle Restricts access to a user's own data tree. Validates relational integrity on create.
     */
    match /userAccounts/{userId}/priceBookEntries/{priceBookEntryId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document based on the path.
     * @param {string} userId The user ID from the path.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of an EXISTING document based on the path.
     * @param {string} userId The user ID from the path.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}